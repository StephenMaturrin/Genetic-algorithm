import random as rand
import numpy as np
from collections import OrderedDict
import pandas as pd
import os
from datetime import datetime

class induvidual():


#TODO differentiation between equals model
#TODO may I use objects or dictionaries ?
#TODO the layers are also features

    def __init__(self,input_layer=12,output_layer=1):
        self.input_layer = input_layer
        self.output_layer = output_layer
        self.learning_rate= 0
        self.n_layers = []
        self.NN_ID=[]
        self.log_individual = {"Fitness": 0, "ID_father": None, "ID_mother": None, "ID_population": None, "NN_ID": None, "layout": None,
                          "Learning_rate": None}

    def create_individial(self):

        self.learning_rate = np.random.randint(1,10)**-np.random.randint(10)
        self.NN_ID.append(self.learning_rate)

        self.log_individual.update({"Learning_rate":self.learning_rate})
        layers = np.random.randint(1,4)
        self.n_layers.append(self.input_layer)
        self.NN_ID.append(self.n_layers[-1])

        for i in range(layers):
            self.n_layers.append(np.random.randint(1,64))
            self.NN_ID.append(self.n_layers[-1])
        self.n_layers.append(self.output_layer)
        self.NN_ID.append(self.n_layers[-1])

        self.log_individual.update({"NN_ID":self.NN_ID})
        self.log_individual.update({"layout": self.n_layers})


        return self.log_individual



    def get_gen(self):
        return self.log_individual

    def update_gen(self,parameter, value):
        self.log_individual.update({parameter:value})

    def get_gen(self,parameter):
        return self.log_individual[parameter]

population = []
aux_population= {}
#
def get_simple_fitness():
    return  np.random.random()

def create_individual(first ,input_layer=None,output_layer=None,NN_ID=None,n_layers=None,learning_rate=None):
    NN_ID = []
    if (first ):
        learning_rate = np.random.randint(1, 10) ** -np.random.randint(10)
        layers = np.random.randint(1, 4)
        n_layers=[]
        n_layers.append(input_layer)

        NN_ID.append(learning_rate)
        NN_ID.append(n_layers[-1])

        for i in range(layers):
            n_layers.append(np.random.randint(1, 64))
            NN_ID.append(n_layers[-1])
        n_layers.append(output_layer)
        NN_ID.append(n_layers[-1])
    else:


        NN_ID.append(learning_rate)
        for i in n_layers:
            NN_ID.append(i)

    # n_layers = np.array(n)
    individual = {"Fitness": [get_simple_fitness()],
            "NN_ID": [[str(i) for i in  NN_ID]],
            "layout": [[str(i) for i in n_layers ]],
            "Learning_rate": learning_rate}

    return individual




def create_population_simple(n_population,input_layer=13, output_layer=1):
    population =[]
    for i in range(n_population):
        population.append(pd.DataFrame(create_individual(first=True,input_layer=input_layer,output_layer=output_layer),index=[i]))

    return  population

def selection (population):

    return population.head(10),population.tail(10)


def ranking (population):
    df = population.sort_values(by='Fitness')
    return df


def overcrossing (group1,group2):
    population=[]
    for index_g1 in range(len(group1)):

        induvidual_id_g1 = group1.NN_ID
        induvidual_id_g1 = induvidual_id_g1.iloc[index_g1]
        induvidual_id_g1 = np.array([float(i) for i in induvidual_id_g1])
        A1 = np.array([i for i in induvidual_id_g1[0:int(len(induvidual_id_g1) / 2)]])
        B1 = np.array([i for i in induvidual_id_g1[int(len(induvidual_id_g1) / 2):len(induvidual_id_g1)]])

        for index_g2 in range(len(group2)):
            induvidual_id_g2 = group2.NN_ID
            induvidual_id_g2 = induvidual_id_g2.iloc[index_g2]
            induvidual_id_g2 = np.array([float(i) for i in induvidual_id_g2])
            A2 = np.array([i for i in induvidual_id_g2[0:int(len(induvidual_id_g2) / 2)]])
            B2 = np.array([i for i in induvidual_id_g2[int(len(induvidual_id_g2) / 2):len(induvidual_id_g2)]])

            new_indiv_1 = np.concatenate([A2, B1])
            new_indiv_2 = np.concatenate([A1, B2])

            population.append(
                pd.DataFrame(create_individual(
                    first=False,
                    learning_rate=new_indiv_2[0],
                    n_layers=new_indiv_2[1:])))
            population.append(
                pd.DataFrame(create_individual(
                    first=False,
                    learning_rate=new_indiv_1[0],
                    n_layers=new_indiv_1[1:])))

    population = pd.concat(population)
    now = datetime.utcnow().strftime('%B-%d-%Y-%H:%M:%S')
    # population.to_csv(os.getcwd()+"/test/{}{}".format(now, ".csv"), sep=';', header=True, float_format='%.6f', index=False)
    return population

pop = create_population_simple(100)
pop = pd.concat(pop)


population_ranked = ranking(pop)
group1, group2 = selection(population_ranked)
pop = overcrossing(group1,group2)
print(pop)
